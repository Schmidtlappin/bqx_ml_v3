# S03.02.07: Implement Intelligence File Update Hooks

**Stage ID**: S03.02.07
**Phase**: MP03.02 - Intelligence Architecture
**Priority**: HIGH
**Estimated Hours**: 8 hours
**Dependencies**: S03.02.05, S03.02.06
**Status**: Planned

---

## üéØ Objective

Implement automated hooks and mechanisms to keep intelligence files synchronized with codebase changes, ensuring the intelligence architecture remains current and accurate throughout the project lifecycle.

---

## üìã Scope

### In Scope
- Git hooks for intelligence file validation and updates
- CI/CD pipeline hooks for automated synchronization
- Automated triggers for intelligence file updates
- Validation workflows to prevent inconsistent states
- Documentation for hook usage and maintenance

### Out of Scope
- Manual intelligence file editing (covered in S03.02.05)
- IntelligenceManager class implementation (covered in S03.02.06)
- Violation policing service (covered in S03.02.08)

---

## üîß Technical Implementation

### 1. Git Hooks

#### Pre-Commit Hook
**Purpose**: Validate intelligence file consistency before commits

**Location**: `.git/hooks/pre-commit`

**Implementation**:
```bash
#!/bin/bash
# Pre-commit hook for intelligence validation

echo "üîç Validating intelligence files..."

# Check if intelligence files exist
if [ ! -d "intelligence" ]; then
    echo "‚ùå Error: intelligence/ directory not found"
    exit 1
fi

# Validate JSON syntax
for file in intelligence/*.json; do
    if ! python -m json.tool "$file" > /dev/null 2>&1; then
        echo "‚ùå Error: Invalid JSON in $file"
        exit 1
    fi
done

# Validate intelligence consistency
python scripts/hooks/validate_intelligence_consistency.py
if [ $? -ne 0 ]; then
    echo "‚ùå Error: Intelligence validation failed"
    exit 1
fi

echo "‚úÖ Intelligence validation passed"
exit 0
```

#### Post-Merge Hook
**Purpose**: Auto-update intelligence files after merges

**Location**: `.git/hooks/post-merge`

**Implementation**:
```bash
#!/bin/bash
# Post-merge hook for intelligence synchronization

echo "üîÑ Synchronizing intelligence files..."

# Check for architecture changes
if git diff-tree -r --name-only HEAD@{1} HEAD | grep -E "(src/|scripts/|*.py)" > /dev/null; then
    echo "üìù Code changes detected, updating intelligence files..."

    # Update context.json with latest commit
    python scripts/hooks/update_intelligence_context.py

    # Update metadata.json with new statistics
    python scripts/hooks/update_intelligence_metadata.py

    echo "‚úÖ Intelligence files synchronized"
fi
```

#### Pre-Push Hook
**Purpose**: Final validation before pushing to remote

**Location**: `.git/hooks/pre-push`

**Implementation**:
```bash
#!/bin/bash
# Pre-push hook for comprehensive intelligence validation

echo "üöÄ Running pre-push intelligence checks..."

# Validate all intelligence layers
python scripts/hooks/comprehensive_intelligence_check.py

if [ $? -ne 0 ]; then
    echo "‚ùå Error: Intelligence validation failed"
    echo "Fix intelligence issues before pushing"
    exit 1
fi

echo "‚úÖ All intelligence checks passed"
exit 0
```

### 2. CI/CD Hooks

#### GitHub Actions Workflow
**Purpose**: Automated intelligence validation and sync on every PR/push

**Location**: `.github/workflows/intelligence-validation.yml`

**Implementation**:
```yaml
name: Intelligence Validation

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  validate-intelligence:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt

      - name: Validate intelligence files
        run: |
          python scripts/hooks/validate_intelligence_consistency.py

      - name: Check for intelligence updates needed
        run: |
          python scripts/hooks/check_intelligence_updates.py

      - name: Validate constraints
        run: |
          python scripts/hooks/validate_constraints.py

      - name: Generate intelligence report
        if: always()
        run: |
          python scripts/hooks/generate_intelligence_report.py > intelligence_report.md

      - name: Upload intelligence report
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: intelligence-report
          path: intelligence_report.md

  sync-intelligence:
    runs-on: ubuntu-latest
    needs: validate-intelligence
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Update intelligence files
        run: |
          python scripts/hooks/auto_update_intelligence.py

      - name: Commit intelligence updates
        if: success()
        run: |
          git config user.name "Intelligence Bot"
          git config user.email "intelligence@bqx-ml.com"
          git add intelligence/
          git commit -m "chore: Auto-update intelligence files [skip ci]" || true
          git push || true
```

### 3. Intelligence Update Triggers

#### Architecture Change Trigger
**Purpose**: Update intelligence when architecture changes

**Script**: `scripts/hooks/on_architecture_change.py`

```python
#!/usr/bin/env python3
"""
Trigger intelligence updates on architecture changes
"""
import json
import os
from datetime import datetime
from pathlib import Path

def detect_architecture_changes():
    """Detect if architecture-related files changed"""
    changed_files = get_changed_files()

    architecture_patterns = [
        'src/models/',
        'src/pipelines/',
        'src/connectors/',
        'scripts/gcp/',
        'requirements.txt'
    ]

    return any(
        any(pattern in file for pattern in architecture_patterns)
        for file in changed_files
    )

def update_ontology():
    """Update ontology.json with new entities/relationships"""
    ontology_path = Path('intelligence/ontology.json')

    with open(ontology_path) as f:
        ontology = json.load(f)

    # Auto-detect new entities from code
    new_entities = scan_code_for_entities()

    # Update ontology
    for entity, metadata in new_entities.items():
        if entity not in ontology['entities']:
            ontology['entities'][entity] = metadata

    # Save updated ontology
    with open(ontology_path, 'w') as f:
        json.dump(ontology, f, indent=2)

    print(f"‚úÖ Updated ontology with {len(new_entities)} new entities")

def update_metadata():
    """Update metadata.json with latest statistics"""
    metadata_path = Path('intelligence/metadata.json')

    with open(metadata_path) as f:
        metadata = json.load(f)

    # Update timestamps
    metadata['system']['last_updated'] = datetime.now().isoformat()

    # Update statistics
    metadata['statistics']['total_tables'] = count_bigquery_tables()
    metadata['statistics']['total_files'] = count_repository_files()

    # Save updated metadata
    with open(metadata_path, 'w') as f:
        json.dump(metadata, f, indent=2)

    print("‚úÖ Updated metadata with latest statistics")

if __name__ == "__main__":
    if detect_architecture_changes():
        print("üîç Architecture changes detected")
        update_ontology()
        update_metadata()
    else:
        print("‚úÖ No architecture changes detected")
```

#### Currency Pair Addition Trigger
**Purpose**: Update intelligence when new currency pairs added

**Script**: `scripts/hooks/on_pair_addition.py`

```python
#!/usr/bin/env python3
"""
Update intelligence files when currency pairs are added
"""
import json
from pathlib import Path

def add_currency_pair(new_pair: str):
    """Add new currency pair to intelligence files"""

    # Update context.json
    context_path = Path('intelligence/context.json')
    with open(context_path) as f:
        context = json.load(f)

    if new_pair not in context['currency_pairs']:
        context['currency_pairs'].append(new_pair)
        context['currency_pairs'].sort()

        with open(context_path, 'w') as f:
            json.dump(context, f, indent=2)

        print(f"‚úÖ Added {new_pair} to context.json")

    # Update metadata.json
    metadata_path = Path('intelligence/metadata.json')
    with open(metadata_path) as f:
        metadata = json.load(f)

    metadata['statistics']['total_pairs'] = len(context['currency_pairs'])
    metadata['statistics']['total_models'] = len(context['currency_pairs']) * 5

    with open(metadata_path, 'w') as f:
        json.dump(metadata, f, indent=2)

    print(f"‚úÖ Updated metadata with {new_pair}")

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: on_pair_addition.py <pair>")
        sys.exit(1)

    new_pair = sys.argv[1].lower()
    add_currency_pair(new_pair)
```

### 4. Validation Scripts

#### Consistency Validator
**Script**: `scripts/hooks/validate_intelligence_consistency.py`

```python
#!/usr/bin/env python3
"""
Validate intelligence file consistency
"""
import json
import sys
from pathlib import Path

def validate_consistency():
    """Validate all intelligence files are consistent"""
    errors = []

    # Load all intelligence files
    intelligence_dir = Path('intelligence')
    files = {
        'context': json.load(open(intelligence_dir / 'context.json')),
        'semantics': json.load(open(intelligence_dir / 'semantics.json')),
        'ontology': json.load(open(intelligence_dir / 'ontology.json')),
        'protocols': json.load(open(intelligence_dir / 'protocols.json')),
        'constraints': json.load(open(intelligence_dir / 'constraints.json')),
        'workflows': json.load(open(intelligence_dir / 'workflows.json')),
        'mandates': json.load(open(intelligence_dir / 'mandates.json')),
        'metadata': json.load(open(intelligence_dir / 'metadata.json'))
    }

    # Check 1: Currency pairs consistent across files
    context_pairs = set(files['context']['currency_pairs'])
    metadata_pairs_count = files['metadata']['statistics']['total_pairs']

    if len(context_pairs) != metadata_pairs_count:
        errors.append(
            f"Currency pair count mismatch: "
            f"context={len(context_pairs)}, metadata={metadata_pairs_count}"
        )

    # Check 2: Model configuration consistent
    context_models = files['context']['model_configuration']['algorithms']
    metadata_models = files['metadata']['statistics']['models_per_pair']

    if len(context_models) != metadata_models:
        errors.append(
            f"Model count mismatch: "
            f"context={len(context_models)}, metadata={metadata_models}"
        )

    # Check 3: Paradigm shift dates consistent
    context_paradigm_date = files['context']['paradigm']['effective_date']
    mandates_paradigm_date = files['mandates']['critical_mandates']['1_BQX_PARADIGM_SHIFT']['date_effective']

    if context_paradigm_date != mandates_paradigm_date:
        errors.append(
            f"Paradigm date mismatch: "
            f"context={context_paradigm_date}, mandates={mandates_paradigm_date}"
        )

    # Check 4: Window type consistent
    context_window = files['context']['feature_configuration']['window_type']
    mandates_window = "ROWS BETWEEN"  # From mandates

    if context_window != mandates_window:
        errors.append(
            f"Window type mismatch: "
            f"context={context_window}, mandates={mandates_window}"
        )

    # Report results
    if errors:
        print("‚ùå Intelligence consistency validation FAILED:")
        for error in errors:
            print(f"  - {error}")
        return False
    else:
        print("‚úÖ Intelligence consistency validation PASSED")
        return True

if __name__ == "__main__":
    success = validate_consistency()
    sys.exit(0 if success else 1)
```

---

## üì¶ Deliverables

### 1. Git Hooks
- [ ] `pre-commit` - Intelligence validation
- [ ] `post-merge` - Auto-update intelligence
- [ ] `pre-push` - Comprehensive checks
- [ ] Hook installation script

### 2. CI/CD Workflows
- [ ] `.github/workflows/intelligence-validation.yml`
- [ ] `.github/workflows/intelligence-sync.yml`
- [ ] Intelligence report generator

### 3. Update Triggers
- [ ] `on_architecture_change.py`
- [ ] `on_pair_addition.py`
- [ ] `on_constraint_change.py`
- [ ] `on_workflow_change.py`

### 4. Validation Scripts
- [ ] `validate_intelligence_consistency.py`
- [ ] `check_intelligence_updates.py`
- [ ] `validate_constraints.py`
- [ ] `generate_intelligence_report.py`

### 5. Documentation
- [ ] Hook usage guide
- [ ] Intelligence update procedures
- [ ] Troubleshooting guide
- [ ] Integration testing guide

---

## üîç Acceptance Criteria

### Functional Requirements
- [ ] Pre-commit hook validates intelligence files before commits
- [ ] Post-merge hook auto-updates intelligence after merges
- [ ] CI/CD pipeline validates intelligence on every PR
- [ ] Architecture changes trigger automatic intelligence updates
- [ ] New currency pairs automatically update all relevant files
- [ ] Consistency validation catches all defined mismatch scenarios

### Non-Functional Requirements
- [ ] Hook execution time < 5 seconds for pre-commit
- [ ] Hook execution time < 10 seconds for post-merge
- [ ] CI/CD validation completes in < 2 minutes
- [ ] Zero false positives in validation
- [ ] Comprehensive error messages for failures

### Documentation Requirements
- [ ] All hooks documented with usage examples
- [ ] Update procedures clearly defined
- [ ] Troubleshooting guide covers common issues
- [ ] Integration testing guide complete

---

## üß™ Testing Strategy

### Unit Tests
- Test each validation function independently
- Test update trigger detection
- Test JSON consistency checks

### Integration Tests
- Test full hook execution flow
- Test CI/CD pipeline end-to-end
- Test update triggers with real file changes

### Validation Tests
- Test all consistency validation scenarios
- Test error detection and reporting
- Test auto-update functionality

---

## üìä Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Hook execution time | < 5s | Git hook timing logs |
| Consistency validation accuracy | 100% | Zero missed inconsistencies |
| Auto-update success rate | > 95% | CI/CD logs |
| False positive rate | < 1% | Manual review |
| Developer satisfaction | > 8/10 | Team survey |

---

## üîó Dependencies

### Prerequisites
- S03.02.05: Intelligence files created
- S03.02.06: IntelligenceManager implemented
- T03.01.04.04: Pre-commit hooks configured (general)

### Dependents
- S03.02.08: Violation policing (uses validation hooks)
- All development stages (benefit from consistent intelligence)

---

## üìö Resources

### Engineering Effort
- **Backend Development**: 4 hours (hook scripts)
- **CI/CD Configuration**: 2 hours (GitHub Actions)
- **Testing**: 1 hour (validation tests)
- **Documentation**: 1 hour (guides)
- **Total**: 8 hours

### Infrastructure
- GitHub Actions runners (existing)
- Git hooks (local)
- Python 3.10+ environment

---

## üöÄ Implementation Plan

### Week 1: Core Hooks
1. Day 1: Create pre-commit hook
2. Day 2: Create post-merge hook
3. Day 3: Create validation scripts

### Week 2: CI/CD & Triggers
1. Day 1: GitHub Actions workflow
2. Day 2: Update triggers
3. Day 3: Testing and documentation

---

## üéØ Related Stages

- **S03.02.05**: Creates intelligence files (prerequisite)
- **S03.02.06**: Implements IntelligenceManager (prerequisite)
- **S03.02.08**: Operational violation policing (complementary)
- **T03.01.04.04**: General pre-commit hooks (integration point)

---

*Stage Specification Version: 1.0*
*Created: 2025-11-25*
*Author: BQXML Chief Engineer*
